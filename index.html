<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>WatchPack — упаковщик музыки для часов</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg:#0b0d10; --card:#151922; --fg:#e9edf1; --muted:#9aa6b2; --accent:#4da3ff; --ok:#18c37e; --warn:#ffb84d; --err:#ff5d5d; --border:rgba(255,255,255,.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--fg); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;}
    .wrap{max-width:980px; margin:0 auto; padding:14px;}
    header{display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:16px}
    h1{font-size:clamp(18px,4.5vw,22px); font-weight:800; margin:0}
    .card{background:var(--card); border:1px solid var(--border); border-radius:16px; padding:12px; box-shadow:0 6px 28px rgba(0,0,0,.25)}
    .grid{display:grid; gap:16px}
    @media(min-width:880px){.grid{grid-template-columns:1.1fr .9fr}}
    .drop{border:1.5px dashed var(--border); border-radius:14px; padding:12px; text-align:center; cursor:pointer; background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0)); position:relative; transition:.18s ease border-color, .18s ease background}
    .drop.dragover{border-color:rgba(77,163,255,.6); background:rgba(77,163,255,.08)}
    .drop.disabled{opacity:.6; pointer-events:none}
    .fileInput{position:absolute; inset:0; opacity:0; cursor:pointer}
    .btn{appearance:none; background:var(--accent); color:#001122; border:0; border-radius:12px; padding:12px 16px; font-weight:700; cursor:pointer}
    .btn[disabled]{opacity:.5; cursor:not-allowed}
    .btn.ghost{background:transparent; color:var(--fg); border:1px solid var(--border)}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    input[type="number"], select, input[type="text"], .pseudo{width:100%; background:#0f1218; border:1px solid var(--border); color:var(--fg); border-radius:12px; padding:10px 12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .switch{display:inline-flex; align-items:center; gap:10px}
    .switch input{appearance:none; width:42px; height:26px; background:#0f1218; border:1px solid var(--border); border-radius:99px; position:relative; outline:none; cursor:pointer}
    .switch input:checked{background:#123148; border-color:#214d73}
    .switch input:before{content:""; position:absolute; inset:3px; width:20px; height:20px; border-radius:50%; background:#fff; transform:translateX(0); transition:.2s}
    .switch input:checked:before{transform:translateX(16px)}
    .list{max-height:320px; overflow:auto; border:1px solid var(--border); border-radius:12px}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th,td{padding:10px 12px; border-bottom:1px solid var(--border)}
    th{position:sticky; top:0; background:#111521; text-align:left; color:#c0c8d2}
    .tag{display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:999px; font-size:12px; background:#0f1218; border:1px solid var(--border); color:var(--muted)}
    progress{width:100%; height:6px}
    .muted{color:var(--muted)}
    .fine{color:var(--ok)}
    .warn{color:var(--warn)}
    .err{color:var(--err)}
    .hr{height:1px; background:var(--border); margin:12px 0}
    footer{opacity:.7; font-size:12px; margin-top:12px}
    .hint{font-size:12px; color:var(--muted)}
    .kbd{padding:2px 6px; border-radius:6px; border:1px solid var(--border); background:#0f1218}
    @media (max-width: 560px){
      .wrap{padding:12px}
      header{margin-bottom:10px}
      .card{padding:12px}
      .drop{padding:12px}
      table{font-size:12px}
      th:nth-child(3), td:nth-child(3){display:none}
      .btn{padding:10px 12px}
      .list{max-height:45vh}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>WatchPack — упаковщик музыки для часов</h1>
      <div class="tag" id="ffmpegStatus">FFmpeg: не загружен</div>
    </header>

    <div class="grid">
      <div class="card">
        <div id="drop" class="drop">
          <strong>Перетащи файлы сюда</strong> или <button id="chooseBtn" class="btn" type="button">выбери</button>
          <input type="file" id="fileInput" class="fileInput" accept="audio/*,video/*" multiple />
        </div>

        <div class="hr"></div>

        <div class="row">
          <div style="flex:1 1 220px">
            <label>Пресет</label>
            <select id="preset">
              <option value="pack30" selected>Часы: весь набор ≤ 30 МБ (авто-битрейт)</option>
              <option value="per3">Трек ≤ 3 МБ (авто по длительности)</option>
              <option value="custom">Свои параметры</option>
            </select>
          </div>
          <div style="flex:1 1 160px">
            <label>Цель (для пресета)</label>
            <input type="number" id="targetMb" min="5" max="2000" step="1" value="30" />
            <div class="hint">Для «набор ≤ … МБ» или «≤ … МБ за трек»</div>
          </div>
          <div style="flex:1 1 160px">
            <label>Битрейт, кбит/с (custom)</label>
            <input type="number" id="bitrate" min="24" max="192" step="4" value="96" />
          </div>
          <div style="flex:1 1 160px">
            <label>Частота, Гц</label>
            <select id="samplerate">
              <option value="44100">44100</option>
              <option value="32000">32000</option>
              <option value="24000">24000</option>
              <option value="22050">22050</option>
            </select>
          </div>
          <div class="switch" title="Моно экономит ~×2">
            <input type="checkbox" id="mono" checked>
            <label for="mono">Моно</label>
          </div>
          <div class="switch" title="Выравнивает громкость (может замедлить обработку)">
            <input type="checkbox" id="normalize">
            <label for="normalize">Нормализация</label>
          </div>
          <button id="calcBtn" class="btn ghost" type="button">Рассчитать битрейт</button>
          <button id="startBtn" class="btn" type="button" disabled>Старт</button>
          <button id="zipBtn" class="btn" type="button" disabled>Собрать ZIP</button>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div>
            <div class="muted">Выбрано файлов: <span id="count">0</span></div>
            <div class="muted">Суммарная длительность: <span id="sumdur">0:00</span></div>
            <div class="muted">Оценка выходного размера: <span id="est">—</span></div>
          </div>
          <div class="tag">Контейнер: MP3 • Кодек: libmp3lame</div>
        </div>
        <div class="list" style="margin-top:8px">
          <table>
            <thead>
              <tr><th>Файл</th><th>Длительность</th><th>Целевой кбит/с</th><th style="width:180px">Прогресс</th><th>Статус</th></tr>
            </thead>
            <tbody id="tbody"><tr><td colspan="5" class="muted">Добавь файлы…</td></tr></tbody>
          </table>
        </div>
        <div style="margin-top:12px">
          <label>Общий прогресс</label>
          <progress id="overall" value="0" max="100"></progress>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>
  <script>
    const $ = (s, p=document) => p.querySelector(s);
    const ui = {
      drop: $('#drop'),
      chooseBtn: $('#chooseBtn'),
      input: $('#fileInput'),
      count: $('#count'),
      sumdur: $('#sumdur'),
      est: $('#est'),
      tbody: $('#tbody'),
      overall: $('#overall'),
      preset: $('#preset'),
      targetMb: $('#targetMb'),
      bitrate: $('#bitrate'),
      samplerate: $('#samplerate'),
      mono: $('#mono'),
      normalize: $('#normalize'),
      calcBtn: $('#calcBtn'),
      startBtn: $('#startBtn'),
      zipBtn: $('#zipBtn'),
      ffmpegStatus: $('#ffmpegStatus'),
    };

    const state = {
      entries: [],
      processing: false,
      ffmpeg: null,
      ffmpegReady: false,
      ffmpegLoading: null,
    };

    const MIN_BITRATE = 24;
    const MAX_BITRATE = 192;

    const clampBitrate = (v) => {
      if (!Number.isFinite(v)) return null;
      const rounded = Math.round(v / 4) * 4;
      return Math.max(MIN_BITRATE, Math.min(MAX_BITRATE, rounded));
    };

    const formatDuration = (seconds) => {
      if (!Number.isFinite(seconds) || seconds <= 0) return '—';
      const total = Math.round(seconds);
      const hrs = Math.floor(total / 3600);
      const mins = Math.floor((total % 3600) / 60);
      const secs = total % 60;
      if (hrs) return `${hrs}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
      return `${mins}:${String(secs).padStart(2,'0')}`;
    };

    const formatSize = (mb) => {
      if (!Number.isFinite(mb) || mb <= 0) return '—';
      if (mb >= 1024) return `${(mb/1024).toFixed(2)} ГБ`;
      return `${mb.toFixed(2)} МБ`;
    };

    const setFfmpegStatus = (text, tone) => {
      ui.ffmpegStatus.textContent = text;
      ui.ffmpegStatus.classList.remove('fine','warn','err');
      if (tone) ui.ffmpegStatus.classList.add(tone);
    };

    const updatePlaceholder = () => {
      if (!state.entries.length) {
        ui.tbody.innerHTML = '<tr><td colspan="5" class="muted">Добавь файлы…</td></tr>';
      }
    };

    const createRow = (entry) => {
      const tr = document.createElement('tr');
      tr.dataset.id = entry.id;

      const nameTd = document.createElement('td');
      nameTd.textContent = entry.file.name;

      const durTd = document.createElement('td');
      durTd.textContent = '—';

      const bitrateTd = document.createElement('td');
      bitrateTd.textContent = '—';

      const progressTd = document.createElement('td');
      const progress = document.createElement('progress');
      progress.max = 100;
      progress.value = 0;
      progressTd.appendChild(progress);
      const percent = document.createElement('div');
      percent.className = 'muted';
      percent.style.marginTop = '4px';
      percent.textContent = '0%';
      progressTd.appendChild(percent);

      const statusTd = document.createElement('td');
      statusTd.textContent = 'Ожидает';

      tr.append(nameTd, durTd, bitrateTd, progressTd, statusTd);
      ui.tbody.appendChild(tr);

      entry.row = tr;
      entry.durationCell = durTd;
      entry.bitrateCell = bitrateTd;
      entry.progressBar = progress;
      entry.progressLabel = percent;
      entry.statusCell = statusTd;
    };

    const getFileId = (file) => `${file.name}__${file.size}__${file.lastModified}`;

    const sanitizeFileName = (name) => {
      const base = name.replace(/\.[^/.]+$/, '');
      const safe = base.replace(/[<>:"/\\|?*\u0000-\u001F]/g, '_').trim() || 'track';
      return `${safe}.mp3`;
    };

    const invalidateOutputs = () => {
      let reset = false;
      state.entries.forEach((entry) => {
        if (entry.state === 'done' || entry.output) reset = true;
        entry.state = 'pending';
        entry.output = null;
        entry.outputName = null;
        entry.progressBar.value = 0;
        entry.progressLabel.textContent = '0%';
        entry.statusCell.textContent = 'Ожидает';
      });
      if (reset) {
        ui.overall.value = 0;
      }
      updateButtons();
    };

    const updateSummary = () => {
      ui.count.textContent = state.entries.length;
      const totalSeconds = state.entries.reduce((acc, entry) => acc + (entry.duration || 0), 0);
      ui.sumdur.textContent = totalSeconds ? formatDuration(totalSeconds) : '0:00';
    };

    const updateEstimate = () => {
      const totalMb = state.entries.reduce((acc, entry) => {
        if (!entry.duration || !entry.targetKbps) return acc;
        const kbTotal = entry.targetKbps * entry.duration;
        const mb = kbTotal / 8 / 1024;
        return acc + mb;
      }, 0);
      ui.est.textContent = totalMb ? formatSize(totalMb) : '—';
    };

    const setEntryBitrate = (entry, kbps) => {
      entry.targetKbps = kbps || null;
      entry.bitrateCell.textContent = kbps ? `${kbps}` : '—';
    };

    const recalcBitrates = () => {
      if (!state.entries.length) {
        updateEstimate();
        updateButtons();
        return null;
      }
      const preset = ui.preset.value;
      const readyEntries = state.entries.filter((entry) => Number.isFinite(entry.duration) && entry.duration > 0);
      let suggested = null;

      if (preset === 'pack30') {
        const target = Number(ui.targetMb.value) || 30;
        const totalDuration = readyEntries.reduce((acc, entry) => acc + entry.duration, 0);
        if (totalDuration > 0) {
          const kbps = clampBitrate((target * 1024 * 1024 * 8) / totalDuration / 1000);
          if (kbps) {
            suggested = kbps;
            state.entries.forEach((entry) => setEntryBitrate(entry, kbps));
          }
        }
      } else if (preset === 'per3') {
        const target = Number(ui.targetMb.value) || 3;
        state.entries.forEach((entry) => {
          if (entry.duration) {
            const kbps = clampBitrate((target * 1024 * 1024 * 8) / entry.duration / 1000);
            setEntryBitrate(entry, kbps);
          } else {
            setEntryBitrate(entry, null);
          }
        });
      } else {
        const custom = clampBitrate(Number(ui.bitrate.value) || 96);
        if (custom) {
          suggested = custom;
          state.entries.forEach((entry) => setEntryBitrate(entry, custom));
        }
      }

      updateEstimate();
      updateButtons();
      return suggested;
    };

    const flashCalcResult = (value) => {
      const original = ui.calcBtn.textContent;
      ui.calcBtn.textContent = `≈ ${value} кбит/с`;
      setTimeout(() => {
        ui.calcBtn.textContent = original;
      }, 1800);
    };

    const updateButtons = () => {
      const hasFiles = state.entries.length > 0;
      const allHaveBitrate = state.entries.every((entry) => !!entry.targetKbps);
      const hasReady = state.entries.some((entry) => entry.state === 'done');

      ui.calcBtn.disabled = !hasFiles || state.processing;
      ui.startBtn.disabled = !hasFiles || state.processing || !allHaveBitrate;
      ui.zipBtn.disabled = !hasReady || state.processing;
    };

    const toggleControls = (locked) => {
      state.processing = locked;
      ui.chooseBtn.disabled = locked;
      ui.input.disabled = locked;
      ui.calcBtn.disabled = locked || !state.entries.length;
      ui.preset.disabled = locked;
      ui.targetMb.disabled = locked || ui.preset.value === 'custom';
      ui.bitrate.disabled = locked || ui.preset.value !== 'custom';
      ui.samplerate.disabled = locked;
      ui.mono.disabled = locked;
      ui.normalize.disabled = locked;
      ui.drop.classList.toggle('disabled', locked);
      updateButtons();
    };

    const handlePresetUi = () => {
      ui.targetMb.disabled = state.processing || ui.preset.value === 'custom';
      ui.bitrate.disabled = state.processing || ui.preset.value !== 'custom';
    };

    const ensureFfmpeg = async () => {
      if (state.ffmpegReady) return state.ffmpeg;
      if (state.ffmpegLoading) return state.ffmpegLoading;
      if (!window.FFmpeg || !FFmpeg.createFFmpeg) {
        setFfmpegStatus('FFmpeg: библиотека не найдена', 'err');
        throw new Error('FFmpeg library missing');
      }
      setFfmpegStatus('FFmpeg: загружается…', 'warn');
      const ffmpeg = FFmpeg.createFFmpeg({
        log: false,
        corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js',
      });
      state.ffmpeg = ffmpeg;
      const loading = ffmpeg.load().then(() => {
        state.ffmpegReady = true;
        setFfmpegStatus('FFmpeg: готов', 'fine');
        return ffmpeg;
      }).catch((err) => {
        setFfmpegStatus('FFmpeg: ошибка загрузки', 'err');
        throw err;
      }).finally(() => {
        state.ffmpegLoading = null;
      });
      state.ffmpegLoading = loading;
      return loading;
    };

    const updateOverall = (ratio) => {
      const percent = Math.round(Math.max(0, Math.min(1, ratio)) * 100);
      ui.overall.value = percent;
    };

    const processEntry = async (entry, index, total) => {
      const ffmpeg = state.ffmpeg;
      const inputName = `input_${index}_${Date.now()}`;
      const outputName = sanitizeFileName(entry.file.name);
      entry.state = 'processing';
      entry.statusCell.textContent = 'Обработка…';
      entry.progressBar.value = 0;
      entry.progressLabel.textContent = '0%';

      const data = await FFmpeg.fetchFile(entry.file);
      ffmpeg.FS('writeFile', inputName, data);

      const args = ['-y', '-i', inputName, '-vn'];
      if (ui.normalize.checked) {
        args.push('-af', 'loudnorm=I=-18:LRA=11:TP=-1.5');
      }
      args.push('-ac', ui.mono.checked ? '1' : '2');
      args.push('-ar', `${ui.samplerate.value}`);
      args.push('-c:a', 'libmp3lame');
      args.push('-b:a', `${entry.targetKbps}k`);
      args.push('-map_metadata', '-1');
      args.push('-id3v2_version', '3');
      args.push(outputName);

      const baseProgress = index / total;
      ffmpeg.setProgress(({ ratio }) => {
        const percent = Math.round(ratio * 100);
        entry.progressBar.value = percent;
        entry.progressLabel.textContent = `${percent}%`;
        updateOverall(baseProgress + ratio / total);
      });

      try {
        await ffmpeg.run(...args);
        const out = ffmpeg.FS('readFile', outputName);
        const buffer = out.buffer.slice(out.byteOffset, out.byteOffset + out.byteLength);
        entry.output = new Blob([buffer], { type: 'audio/mpeg' });
        entry.outputName = outputName;
        entry.state = 'done';
        entry.statusCell.innerHTML = '<span class="fine">Готово</span>';
        entry.progressBar.value = 100;
        entry.progressLabel.textContent = '100%';
        updateOverall((index + 1) / total);
      } catch (err) {
        console.error(err);
        entry.state = 'error';
        entry.statusCell.innerHTML = '<span class="err">Ошибка</span>';
        entry.progressBar.value = 0;
        entry.progressLabel.textContent = '0%';
        updateOverall((index + 1) / total);
      } finally {
        try { ffmpeg.FS('unlink', inputName); } catch (_) {}
        try { ffmpeg.FS('unlink', outputName); } catch (_) {}
        ffmpeg.setProgress(() => {});
      }
    };

    const processAll = async () => {
      if (!state.entries.length || state.processing) return;
      if (state.entries.some((entry) => !entry.targetKbps)) return;
      toggleControls(true);
      ui.overall.value = 0;
      try {
        await ensureFfmpeg();
        const total = state.entries.length;
        for (let i = 0; i < total; i += 1) {
          const entry = state.entries[i];
          await processEntry(entry, i, total);
        }
        updateOverall(1);
      } catch (err) {
        console.error(err);
      } finally {
        toggleControls(false);
        updateButtons();
      }
    };

    const buildZip = async () => {
      const ready = state.entries.filter((entry) => entry.state === 'done' && entry.output && entry.outputName);
      if (!ready.length) return;
      const zip = new JSZip();
      ready.forEach((entry) => {
        zip.file(entry.outputName, entry.output);
      });
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'watchpack.zip';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };

    const loadDuration = (entry) => {
      const el = document.createElement(entry.file.type.startsWith('video/') ? 'video' : 'audio');
      el.preload = 'metadata';
      const url = URL.createObjectURL(entry.file);
      const cleanup = () => {
        URL.revokeObjectURL(url);
        el.remove();
      };
      el.onloadedmetadata = () => {
        if (!Number.isFinite(el.duration) || el.duration === Infinity) {
          el.currentTime = 1e101;
          el.ontimeupdate = () => {
            cleanup();
            entry.duration = el.duration || 0;
            entry.durationCell.textContent = formatDuration(entry.duration);
            recalcBitrates();
            updateSummary();
          };
        } else {
          const duration = el.duration || 0;
          cleanup();
          entry.duration = duration;
          entry.durationCell.textContent = formatDuration(duration);
          recalcBitrates();
          updateSummary();
        }
      };
      el.onerror = () => {
        cleanup();
        entry.duration = 0;
        entry.durationCell.textContent = '—';
        recalcBitrates();
        updateSummary();
      };
      el.src = url;
    };

    const onFiles = (fileList) => {
      if (state.processing) return;
      const files = Array.from(fileList || []);
      if (!files.length) return;
      if (!state.entries.length) ui.tbody.innerHTML = '';
      let added = 0;
      files.forEach((file) => {
        const id = getFileId(file);
        if (state.entries.some((entry) => entry.id === id)) return;
        const entry = {
          id,
          file,
          duration: null,
          targetKbps: null,
          output: null,
          outputName: null,
          state: 'pending',
        };
        createRow(entry);
        state.entries.push(entry);
        loadDuration(entry);
        added += 1;
      });
      if (added) {
        invalidateOutputs();
        updateSummary();
        recalcBitrates();
        updateButtons();
      }
      updatePlaceholder();
      ui.input.value = '';
    };

    const handleCalcClick = () => {
      if (!state.entries.length || state.processing) return;
      const suggested = recalcBitrates();
      if (suggested && ui.preset.value !== 'custom') {
        flashCalcResult(suggested);
      }
    };

    const initDragAndDrop = () => {
      ['dragenter','dragover'].forEach((evt) => {
        ui.drop.addEventListener(evt, (e) => {
          e.preventDefault();
          if (state.processing) return;
          ui.drop.classList.add('dragover');
        });
      });
      ['dragleave','drop'].forEach((evt) => {
        ui.drop.addEventListener(evt, (e) => {
          e.preventDefault();
          ui.drop.classList.remove('dragover');
        });
      });
      ui.drop.addEventListener('drop', (e) => {
        if (state.processing) return;
        onFiles(e.dataTransfer.files);
      });
    };

    const bindEvents = () => {
      ui.chooseBtn.addEventListener('click', () => {
        if (state.processing) return;
        ui.input.click();
      });
      ui.input.addEventListener('change', (e) => onFiles(e.target.files));
      ui.preset.addEventListener('change', () => {
        handlePresetUi();
        invalidateOutputs();
        recalcBitrates();
      });
      ui.targetMb.addEventListener('change', () => {
        invalidateOutputs();
        recalcBitrates();
      });
      ui.bitrate.addEventListener('change', () => {
        invalidateOutputs();
        recalcBitrates();
      });
      ui.samplerate.addEventListener('change', invalidateOutputs);
      ui.mono.addEventListener('change', invalidateOutputs);
      ui.normalize.addEventListener('change', invalidateOutputs);
      ui.calcBtn.addEventListener('click', handleCalcClick);
      ui.startBtn.addEventListener('click', processAll);
      ui.zipBtn.addEventListener('click', () => {
        if (!ui.zipBtn.disabled) buildZip();
      });
      initDragAndDrop();
    };

    const init = () => {
      ui.preset.value = 'pack30';
      bindEvents();
      handlePresetUi();
      updatePlaceholder();
      updateSummary();
      updateEstimate();
      updateButtons();
    };

    init();
  </script>
</body>
</html>
